component extends="coldbox.system.testing.BaseTestCase" appMapping="/" accessors=true{

	property name="cbSwaggerSettings" 	inject="coldbox:setting:cbSwagger";
	property name="wirebox" 			inject="wirebox";
	property name="controller" 			inject="coldbox";

	this.loadColdbox=true;
	this.unloadColdbox=true;

	/*********************************** LIFE CYCLE Methods ***********************************/

	function beforeAll(){

		super.beforeAll();

		// do your own stuff here
		expect( application ).toHaveKey( "wirebox", "Wirebox is required to run this test" );
		application.wirebox.autowire( this );
		expect( isNull( Controller ) ).toBeFalse( "Autowiring failed.  Could not continue" );

		variables.testHandlerMetadata = getMetaData( createObject( "component", "handlers.api.v1.Users" ) );
	}

	function afterAll(){
		// do your own stuff here
		super.afterAll();

	}

	/*********************************** BDD SUITES ***********************************/

	function run(){

		describe( "Tests core RouteParser Methods", function(){

			it("Tests the creation document generated by createDocFromRoutes", function(){
				var RoutesParser = Wirebox.getInstance( "RoutesParser@cbSwagger" );
				expect( RoutesParser ).toBeComponent();

				var APIDoc = RoutesParser.createDocFromRoutes();
				expect( APIDoc ).toBeComponent();

				var NormalizedDoc = APIDoc.getNormalizedDocument();

				expect( NormalizedDoc ).toBeStruct();
				expect(	NormalizedDoc ).toHaveKey( "swagger" );

				expect( isJSON( APIDoc.asJSON() ) ).toBeTrue();

				variables.APIDoc = APIDoc;

			});

			it( "Tests casting", function(){

				expect( variables ).toHaveKey( "APIDoc", "No APIDoc was found to test.  Could not continue." );

				var doc = APIDoc.getNormalizedDocument();

				expect( doc ).toBeStruct();
				expect( doc ).toHaveKey( "paths" );

				for( var pathKey in doc[ "paths" ] ){
					
					if( left( pathKey, 2 ) == 'x-' ) continue;

					for( var methodKey in doc[ "paths" ][ pathKey ] ){

						if( left( methodKey, 2 ) == 'x-' ) continue;

						var method = doc[ "paths" ][ pathKey ][ methodKey ];
						expect( method ).toBeStruct();
						if( structKeyExists( method, "parameters" ) ){

							expect( method[ "parameters" ] ).toBeArray();
						
						}
					}
				}

			});

			it( "Tests the API Document against the routing configuration", function(){
				var SwaggerUtil = Wirebox.getInstance( "OpenAPIUtil@SwaggerSDK" );
				expect( variables ).toHaveKey( "APIDoc", "No APIDoc was found to test.  Could not continue." );

				var normalizedDoc = variables.APIDoc.getNormalizedDocument();
				expect( normalizedDoc ).toHaveKey( "paths" );

				var APIPaths = normalizedDoc[ "paths" ];
				//pull our routing configuration
				var apiPrefixes = cbSwaggerSettings.routes;
				expect( apiPrefixes ).toBeArray();

				var CBRoutes = getController().getInterceptorService().getInterceptor("SES").getRoutes();
				expect( CBRoutes ).toBeArray();

				expect( arrayLen( CBRoutes ) ).toBeGT( 0 );

				//Tests that all of our configured paths exist
				for( var routePrefix in apiPrefixes ){
					for( var route in cbRoutes ){
						if( left( route.pattern, len( routePrefix ) ) == routePrefix ){
							var translatedPath = SwaggerUtil.translatePath( route.pattern );
							if( !len( route.moduleRouting ) ){
								expect( normalizedDoc[ "paths" ] ).toHaveKey( translatedPath );
							}
						}
					}
				}

			});

			it( "Tests the API Document for module introspection", function(){
				var SwaggerUtil = Wirebox.getInstance( "OpenAPIUtil@SwaggerSDK" );
				expect( variables ).toHaveKey( "APIDoc", "No APIDoc was found to test.  Could not continue." );

				var normalizedDoc = variables.APIDoc.getNormalizedDocument();
				expect( normalizedDoc ).toHaveKey( "paths" );

				var APIPaths = normalizedDoc[ "paths" ];
				//pull our routing configuration
				var apiPrefixes = cbSwaggerSettings.routes;
				expect( apiPrefixes ).toBeArray();

				var TLRoutes = getController().getInterceptorService().getInterceptor( "SES" ).getRoutes();
				expect( TLRoutes ).toBeArray();

				expect( arrayLen( TLRoutes ) ).toBeGT( 0 );

				for( var TLRoute in TLRoutes ){
					if( len( TLRoute.moduleRouting ) ){
						var CBRoutes = getController().getInterceptorService()
							.getInterceptor( "SES" )
							.getModuleRoutes( TLRoute.moduleRouting );

						//Tests that all of our configured paths exist
						for( var routePrefix in apiPrefixes ){
							//recurse into the module routes
							for( var route in CBRoutes ){
								if( left( route.pattern, len( routePrefix ) ) == routePrefix ){
									var translatedPath = SwaggerUtil.translatePath( route.pattern );
									expect( normalizedDoc[ "paths" ] ).toHaveKey( translatedPath );
								}
							}
						}
					}
				}

			});

			it( "Tests that route-based parameters are appended to all method params", function(){
				
				expect( variables ).toHaveKey( "APIDoc", "No APIDoc was found to test.  Could not continue." );

				var normalizedDoc = variables.APIDoc.getNormalizedDocument();

				expect( normalizedDoc ).toHaveKey( "paths" );
				expect( normalizedDoc[ "paths" ] ).toHaveKey( "/api/v1/users/{id}" );
				expect( normalizedDoc[ "paths" ][ "/api/v1/users/{id}" ] ).toBeStruct();

				var path = normalizedDoc[ "paths" ][ "/api/v1/users/{id}" ];

				for( var methodKey in path ){

					if( isSimpleValue( path[ methodKey ] ) ) continue;

					expect( path[ methodKey ] ).toHaveKey( "parameters" );

					var idParamSearch = arrayFilter( 
						path[ methodKey ][ "parameters" ],
						function( parameter ){							
							return ( structKeyExists( parameter, "name" ) && parameter[ "name" ] == "id" );	
						} 
					);


					expect( arrayLen( idParamSearch ) ).toBe( 1 );

					expect( idParamSearch[ 1 ].required ).toBeTrue();
					expect( idParamSearch[ 1 ][ "in" ] ).toBe( "path" );
				}


			} );

			it( "Tests the ability to parse parameter metadata definitions", function(){
				
				expect( variables ).toHaveKey( "APIDoc", "No APIDoc was found to test.  Could not continue." );

				var normalizedDoc = variables.APIDoc.getNormalizedDocument();

				expect( normalizedDoc ).toHaveKey( "paths" );
				expect( normalizedDoc[ "paths" ] ).toHaveKey( "/api/v1/users/{id}" );
				expect( normalizedDoc[ "paths" ][ "/api/v1/users/{id}" ] );

				var path = normalizedDoc[ "paths" ][ "/api/v1/users/{id}" ];

				expect( path ).toHaveKey( "put" );

				expect( path[ "put" ] ).toHaveKey( "parameters" );

				var firstNameSearch = arrayFilter( 
					path[ "put" ][ "parameters" ], 
					function( parameter ){							
						return structKeyExists( parameter, "name" ) && parameter[ "name" ] == "firstname";	
					}
				);

				expect( arrayLen( firstNameSearch ) ).toBe( 1 );

				expect( firstNameSearch[ 1 ] )
										.toBeStruct()
										.toHaveKey( "required" );

				expect( firstNameSearch[ 1 ].required ).toBe( false );

			} );


			it( "Tests the ability to parse response metadata definitions", function(){
				
				
				
				expect( variables ).toHaveKey( "APIDoc", "No APIDoc was found to test.  Could not continue." );

				var normalizedDoc = variables.APIDoc.getNormalizedDocument();

				expect( normalizedDoc ).toHaveKey( "paths" );
				expect( normalizedDoc[ "paths" ] ).toHaveKey( "/api/v1/users/{id}" );
				expect( normalizedDoc[ "paths" ][ "/api/v1/users/{id}" ] );

				var path = normalizedDoc[ "paths" ][ "/api/v1/users/{id}" ];

				expect( path ).toHaveKey( "put" );

				expect( path[ "put" ] ).toHaveKey( "responses" );
				expect( path[ "put" ][ "responses" ] ).toHaveKey( "default" );

				expect( path[ "put" ][ "responses" ][ "default" ] )
													.toBeStruct()
													.toHaveKey( "description" )
													.toHaveKey( "schema" );

				expect(
					path[ "put" ][ "responses" ][ "default" ][ "description" ]
				).toBe( "User successfully updated" );

				expect(
					path[ "put" ][ "responses" ][ "default" ][ "schema" ]
				).toBeStruct();


			} );

		});

	}

}
